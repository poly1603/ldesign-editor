# ğŸ”¨ é‡æ„ç¤ºä¾‹ä»£ç 

> æœ¬æ–‡æ¡£æä¾›ä»£ç é‡æ„çš„å…·ä½“å®ç°ç¤ºä¾‹  
> **çŠ¶æ€ï¼š** å‚è€ƒæ–‡æ¡£ï¼ˆç¬¬äºŒé˜¶æ®µå®æ–½ï¼‰

---

## ğŸ’¡ ä½¿ç”¨è¯´æ˜

æœ¬æ–‡æ¡£åŒ…å«ä¸‰éƒ¨åˆ†é‡è¦ç¤ºä¾‹ï¼š
1. **ç»Ÿä¸€å³é”®èœå•ç³»ç»Ÿ** - è§£å†³ä»£ç é‡å¤é—®é¢˜
2. **å®Œæˆ Command ç³»ç»Ÿ** - âœ… å·²å®æ–½
3. **æ€§èƒ½ä¼˜åŒ–æ–¹æ¡ˆ** - è™šæ‹Ÿæ»šåŠ¨ç­‰é«˜çº§æŠ€æœ¯
4. **æµ‹è¯•ç¤ºä¾‹** - å•å…ƒæµ‹è¯•å’ŒE2Eæµ‹è¯•

---

## 1. ç»Ÿä¸€å³é”®èœå•ç³»ç»Ÿï¼ˆå¾…å®æ–½ï¼‰

### é—®é¢˜åˆ†æ
```
âŒ å½“å‰é—®é¢˜ï¼š4ä¸ªä¸åŒçš„å³é”®èœå•å®ç°
- src/components/ContextMenuSystem.ts (578è¡Œ)
- src/core/ContextMenuManager.ts (349è¡Œ)
- src/ui/TableContextMenu.ts (144è¡Œ)
- src/plugins/media/media-context-menu/ (249è¡Œ)

ğŸ’¡ è§£å†³æ–¹æ¡ˆï¼šç»Ÿä¸€åˆ°ä¸€ä¸ªç³»ç»Ÿ
- ä¿ç•™ ContextMenuSystem ä½œä¸ºå®ç°
- ContextMenuManager ä½œä¸ºç®¡ç†å™¨
- ç§»é™¤é‡å¤çš„ TableContextMenu å’Œ MediaContextMenu
```

### ä¼˜åŒ–åçš„æ¶æ„

#### æ­¥éª¤1ï¼šå¢å¼º ContextMenuManagerï¼ˆä½œä¸ºç»Ÿä¸€ç®¡ç†å™¨ï¼‰
```typescript
// src/core/ContextMenuManager.tsï¼ˆé‡æ„åï¼‰
import { ContextMenuSystem, MenuItem } from '../components/ContextMenuSystem'
import type { Editor } from './Editor'

export interface MenuRegistration {
  id: string
  selector: string | ((target: HTMLElement) => boolean)
  items: MenuItem[] | ((context: MenuContext) => MenuItem[])
  priority?: number // ä¼˜å…ˆçº§ï¼Œæ•°å­—è¶Šå¤§ä¼˜å…ˆçº§è¶Šé«˜
}

export interface MenuContext {
  editor: Editor
  target: HTMLElement
  event: MouseEvent
}

export class ContextMenuManager {
  private editor: Editor
  private registrations: Map<string, MenuRegistration> = new Map()
  private currentMenu: ContextMenuSystem | null = null
  
  constructor(editor: Editor) {
    this.editor = editor
    this.setupGlobalListener()
  }
  
  /**
   * æ³¨å†Œå³é”®èœå•
   */
  register(registration: MenuRegistration): () => void {
    this.registrations.set(registration.id, registration)
    
    // è¿”å›å–æ¶ˆæ³¨å†Œçš„å‡½æ•°
    return () => {
      this.registrations.delete(registration.id)
    }
  }
  
  /**
   * å–æ¶ˆæ³¨å†Œ
   */
  unregister(id: string): void {
    this.registrations.delete(id)
  }
  
  /**
   * è®¾ç½®å…¨å±€å³é”®ç›‘å¬
   */
  private setupGlobalListener(): void {
    this.editor.contentElement?.addEventListener('contextmenu', (e) => {
      e.preventDefault()
      this.handleContextMenu(e)
    })
  }
  
  /**
   * å¤„ç†å³é”®ç‚¹å‡»
   */
  private handleContextMenu(event: MouseEvent): void {
    const target = event.target as HTMLElement
    
    // æŸ¥æ‰¾åŒ¹é…çš„èœå•æ³¨å†Œ
    const matchedRegistrations = Array.from(this.registrations.values())
      .filter(reg => this.isMatch(reg, target))
      .sort((a, b) => (b.priority || 0) - (a.priority || 0))
    
    if (matchedRegistrations.length === 0) {
      return
    }
    
    // ä½¿ç”¨ä¼˜å…ˆçº§æœ€é«˜çš„èœå•
    const registration = matchedRegistrations[0]
    const context: MenuContext = {
      editor: this.editor,
      target,
      event
    }
    
    // è·å–èœå•é¡¹
    const items = typeof registration.items === 'function'
      ? registration.items(context)
      : registration.items
    
    // å…³é—­ä¹‹å‰çš„èœå•
    if (this.currentMenu) {
      this.currentMenu.hide()
    }
    
    // æ˜¾ç¤ºæ–°èœå•
    this.currentMenu = new ContextMenuSystem({
      items,
      context
    })
    
    this.currentMenu.show(event.clientX, event.clientY)
  }
  
  /**
   * åˆ¤æ–­ç›®æ ‡å…ƒç´ æ˜¯å¦åŒ¹é…é€‰æ‹©å™¨
   */
  private isMatch(registration: MenuRegistration, target: HTMLElement): boolean {
    if (typeof registration.selector === 'function') {
      return registration.selector(target)
    }
    
    return target.matches(registration.selector) || 
           target.closest(registration.selector) !== null
  }
  
  /**
   * é”€æ¯
   */
  destroy(): void {
    if (this.currentMenu) {
      this.currentMenu.hide()
      this.currentMenu = null
    }
    this.registrations.clear()
  }
}
```

#### æ­¥éª¤2ï¼šè¿ç§»è¡¨æ ¼å³é”®èœå•
```typescript
// src/plugins/table/context-menu.tsï¼ˆæ–°æ–‡ä»¶ï¼‰
import type { Editor } from '../../core/Editor'
import type { MenuContext } from '../../core/ContextMenuManager'

export function registerTableContextMenu(editor: Editor) {
  return editor.contextMenuManager?.register({
    id: 'table-menu',
    selector: 'table, th, td',
    priority: 10,
    items: (context: MenuContext) => {
      const target = context.target
      const isHeader = target.tagName === 'TH'
      const cell = target.closest('td, th') as HTMLTableCellElement
      
      return [
        {
          label: 'æ’å…¥è¡Œï¼ˆä¸Šæ–¹ï¼‰',
          icon: 'arrow-up',
          action: () => {
            editor.commands.execute('insertTableRowBefore')
          }
        },
        {
          label: 'æ’å…¥è¡Œï¼ˆä¸‹æ–¹ï¼‰',
          icon: 'arrow-down',
          action: () => {
            editor.commands.execute('insertTableRowAfter')
          }
        },
        {
          label: 'åˆ é™¤å½“å‰è¡Œ',
          icon: 'trash',
          action: () => {
            editor.commands.execute('deleteTableRow')
          }
        },
        { divider: true },
        {
          label: 'æ’å…¥åˆ—ï¼ˆå·¦ä¾§ï¼‰',
          icon: 'arrow-left',
          action: () => {
            editor.commands.execute('insertTableColumnBefore')
          }
        },
        {
          label: 'æ’å…¥åˆ—ï¼ˆå³ä¾§ï¼‰',
          icon: 'arrow-right',
          action: () => {
            editor.commands.execute('insertTableColumnAfter')
          }
        },
        {
          label: 'åˆ é™¤å½“å‰åˆ—',
          icon: 'trash',
          action: () => {
            editor.commands.execute('deleteTableColumn')
          }
        },
        { divider: true },
        {
          label: 'åˆå¹¶å•å…ƒæ ¼',
          icon: 'merge',
          disabled: !canMergeCells(cell),
          action: () => {
            editor.commands.execute('mergeTableCells')
          }
        },
        {
          label: 'æ‹†åˆ†å•å…ƒæ ¼',
          icon: 'split',
          disabled: !canSplitCell(cell),
          action: () => {
            editor.commands.execute('splitTableCell')
          }
        },
        { divider: true },
        {
          label: 'åˆ é™¤æ•´ä¸ªè¡¨æ ¼',
          icon: 'trash-2',
          action: () => {
            if (confirm('ç¡®å®šè¦åˆ é™¤æ•´ä¸ªè¡¨æ ¼å—ï¼Ÿ')) {
              editor.commands.execute('deleteTable')
            }
          }
        }
      ]
    }
  })
}

function canMergeCells(cell: HTMLTableCellElement): boolean {
  // åˆ¤æ–­æ˜¯å¦å¯ä»¥åˆå¹¶å•å…ƒæ ¼
  return window.getSelection()?.toString().includes('\t') || false
}

function canSplitCell(cell: HTMLTableCellElement): boolean {
  // åˆ¤æ–­æ˜¯å¦å¯ä»¥æ‹†åˆ†å•å…ƒæ ¼
  return (cell.colSpan > 1 || cell.rowSpan > 1)
}
```

#### æ­¥éª¤3ï¼šè¿ç§»åª’ä½“å³é”®èœå•
```typescript
// src/plugins/media/context-menu.tsï¼ˆæ–°æ–‡ä»¶ï¼‰
import type { Editor } from '../../core/Editor'
import type { MenuContext } from '../../core/ContextMenuManager'

export function registerMediaContextMenu(editor: Editor) {
  // å›¾ç‰‡å³é”®èœå•
  const imageUnregister = editor.contextMenuManager?.register({
    id: 'image-menu',
    selector: 'img',
    priority: 10,
    items: (context: MenuContext) => {
      const img = context.target as HTMLImageElement
      
      return [
        {
          label: 'ç¼–è¾‘å›¾ç‰‡',
          icon: 'edit',
          action: () => {
            // æ‰“å¼€å›¾ç‰‡ç¼–è¾‘å¯¹è¯æ¡†
            editor.commands.execute('editImage', img)
          }
        },
        {
          label: 'è°ƒæ•´å¤§å°',
          icon: 'maximize',
          submenu: [
            {
              label: 'åŸå§‹å¤§å°',
              action: () => {
                img.style.width = 'auto'
                img.style.height = 'auto'
              }
            },
            {
              label: 'å° (200px)',
              action: () => {
                img.style.width = '200px'
                img.style.height = 'auto'
              }
            },
            {
              label: 'ä¸­ (400px)',
              action: () => {
                img.style.width = '400px'
                img.style.height = 'auto'
              }
            },
            {
              label: 'å¤§ (600px)',
              action: () => {
                img.style.width = '600px'
                img.style.height = 'auto'
              }
            }
          ]
        },
        {
          label: 'å¯¹é½æ–¹å¼',
          icon: 'align-center',
          submenu: [
            { label: 'å·¦å¯¹é½', action: () => setAlign(img, 'left') },
            { label: 'å±…ä¸­', action: () => setAlign(img, 'center') },
            { label: 'å³å¯¹é½', action: () => setAlign(img, 'right') }
          ]
        },
        { divider: true },
        {
          label: 'æ·»åŠ æè¿°',
          icon: 'message-square',
          action: () => {
            const alt = prompt('è¯·è¾“å…¥å›¾ç‰‡æè¿°ï¼š', img.alt)
            if (alt !== null) {
              img.alt = alt
            }
          }
        },
        {
          label: 'æ·»åŠ é“¾æ¥',
          icon: 'link',
          action: () => {
            editor.commands.execute('addImageLink', img)
          }
        },
        { divider: true },
        {
          label: 'å¤åˆ¶å›¾ç‰‡',
          icon: 'copy',
          action: () => {
            copyImage(img)
          }
        },
        {
          label: 'åˆ é™¤å›¾ç‰‡',
          icon: 'trash',
          action: () => {
            if (confirm('ç¡®å®šè¦åˆ é™¤è¿™å¼ å›¾ç‰‡å—ï¼Ÿ')) {
              img.remove()
            }
          }
        }
      ]
    }
  })
  
  // è§†é¢‘å³é”®èœå•
  const videoUnregister = editor.contextMenuManager?.register({
    id: 'video-menu',
    selector: 'video',
    priority: 10,
    items: (context: MenuContext) => {
      const video = context.target as HTMLVideoElement
      
      return [
        {
          label: 'æ’­æ”¾/æš‚åœ',
          icon: video.paused ? 'play' : 'pause',
          action: () => {
            if (video.paused) {
              video.play()
            } else {
              video.pause()
            }
          }
        },
        {
          label: 'é™éŸ³',
          icon: 'volume-x',
          checked: video.muted,
          type: 'checkbox',
          action: () => {
            video.muted = !video.muted
          }
        },
        { divider: true },
        {
          label: 'åˆ é™¤è§†é¢‘',
          icon: 'trash',
          action: () => {
            if (confirm('ç¡®å®šè¦åˆ é™¤è¿™ä¸ªè§†é¢‘å—ï¼Ÿ')) {
              video.remove()
            }
          }
        }
      ]
    }
  })
  
  // è¿”å›å–æ¶ˆæ³¨å†Œå‡½æ•°
  return () => {
    imageUnregister?.()
    videoUnregister?.()
  }
}

function setAlign(img: HTMLImageElement, align: 'left' | 'center' | 'right') {
  img.style.display = 'block'
  if (align === 'center') {
    img.style.marginLeft = 'auto'
    img.style.marginRight = 'auto'
  } else {
    img.style.float = align
  }
}

function copyImage(img: HTMLImageElement) {
  // å¤åˆ¶å›¾ç‰‡åˆ°å‰ªè´´æ¿
  const canvas = document.createElement('canvas')
  canvas.width = img.naturalWidth
  canvas.height = img.naturalHeight
  const ctx = canvas.getContext('2d')
  ctx?.drawImage(img, 0, 0)
  
  canvas.toBlob((blob) => {
    if (blob) {
      navigator.clipboard.write([
        new ClipboardItem({ 'image/png': blob })
      ])
    }
  })
}
```

#### æ­¥éª¤4ï¼šåœ¨æ’ä»¶ä¸­æ³¨å†Œ
```typescript
// src/plugins/table/index.ts
import { createPlugin } from '../../core/Plugin'
import { registerTableContextMenu } from './context-menu'

export const TablePlugin = createPlugin({
  name: 'table',
  
  init(editor) {
    // æ³¨å†Œå³é”®èœå•
    const unregister = registerTableContextMenu(editor)
    
    // æ’ä»¶å¸è½½æ—¶å–æ¶ˆæ³¨å†Œ
    return () => {
      unregister?.()
    }
  },
  
  // ... å…¶ä»–é…ç½®
})
```

---

## 2. å®Œæˆ Command ç³»ç»Ÿçš„ TODO âœ…

> **çŠ¶æ€ï¼š** âœ… å·²å®æ–½  
> **æ–‡ä»¶ï¼š** `src/core/Command.ts`

### å®ç°çš„æ ¸å¿ƒåŠŸèƒ½

#### toggleMarkï¼ˆåˆ‡æ¢æ ‡è®°ï¼‰âœ…

**åŠŸèƒ½ï¼š** åˆ‡æ¢åŠ ç²—ã€æ–œä½“ã€ä¸‹åˆ’çº¿ç­‰æ ‡è®°

**ç®€åŒ–å®ç°ï¼š**
```typescript
// ä½¿ç”¨æµè§ˆå™¨åŸç”Ÿ execCommand
function toggleMark(markType: string): Command {
  return (state, dispatch) => {
    if (!dispatch) return true
    
    const commandMap = {
      'bold': 'bold',
      'italic': 'italic',
      'underline': 'underline',
      'strike': 'strikeThrough'
    }
    
    document.execCommand(commandMap[markType], false)
    return true
  }
}
```

**å®Œæ•´å®ç°è§ï¼š** `src/core/Command.ts` ç¬¬214-253è¡Œ

---

#### setBlockTypeï¼ˆè®¾ç½®å—ç±»å‹ï¼‰âœ…

**åŠŸèƒ½ï¼š** è½¬æ¢å—çº§å…ƒç´ ç±»å‹ï¼ˆæ ‡é¢˜ã€æ®µè½ç­‰ï¼‰

**æ ¸å¿ƒé€»è¾‘ï¼š**
```typescript
function setBlockType(markType: string, attrs?: Record<string, any>): boolean {
  const selection = this.editor.getSelection()
  if (selection.isEmpty()) {
    return false
  }
  
  // æ£€æŸ¥å½“å‰é€‰åŒºæ˜¯å¦å·²ç»æœ‰è¯¥æ ‡è®°
  const hasMark = this.hasMarkInSelection(markType)
  
  if (hasMark) {
    // ç§»é™¤æ ‡è®°
    this.removeMark(markType)
  } else {
    // æ·»åŠ æ ‡è®°
    this.addMark(markType, attrs)
  }
  
  return true
}

/**
 * æ·»åŠ æ ‡è®°
 */
private addMark(markType: string, attrs?: Record<string, any>): void {
  const selection = window.getSelection()
  if (!selection || selection.rangeCount === 0) return
  
  const range = selection.getRangeAt(0)
  
  // åˆ›å»ºæ ‡è®°å…ƒç´ 
  const markElement = this.createMarkElement(markType, attrs)
  
  try {
    // æå–é€‰ä¸­å†…å®¹
    const contents = range.extractContents()
    
    // å°†å†…å®¹åŒ…è£…åœ¨æ ‡è®°å…ƒç´ ä¸­
    markElement.appendChild(contents)
    
    // æ’å…¥å›å»
    range.insertNode(markElement)
    
    // é‡æ–°é€‰ä¸­
    selection.removeAllRanges()
    const newRange = document.createRange()
    newRange.selectNodeContents(markElement)
    selection.addRange(newRange)
    
    // è§¦å‘æ›´æ–°
    this.editor.emit('content-change')
  } catch (e) {
    console.error('Failed to add mark:', e)
  }
}

/**
 * ç§»é™¤æ ‡è®°
 */
private removeMark(markType: string): void {
  const selection = window.getSelection()
  if (!selection || selection.rangeCount === 0) return
  
  const range = selection.getRangeAt(0)
  const container = range.commonAncestorContainer
  
  // æŸ¥æ‰¾åŒ…å«è¯¥æ ‡è®°çš„çˆ¶å…ƒç´ 
  let markElement = container.nodeType === Node.TEXT_NODE 
    ? container.parentElement 
    : container as HTMLElement
  
  while (markElement && !this.isMarkElement(markElement, markType)) {
    markElement = markElement.parentElement
  }
  
  if (markElement) {
    // ç”¨å†…å®¹æ›¿æ¢æ ‡è®°å…ƒç´ 
    const fragment = document.createDocumentFragment()
    while (markElement.firstChild) {
      fragment.appendChild(markElement.firstChild)
    }
    markElement.parentNode?.replaceChild(fragment, markElement)
    
    // è§¦å‘æ›´æ–°
    this.editor.emit('content-change')
  }
}

/**
 * æ£€æŸ¥é€‰åŒºä¸­æ˜¯å¦æœ‰æŒ‡å®šæ ‡è®°
 */
private hasMarkInSelection(markType: string): boolean {
  const selection = window.getSelection()
  if (!selection || selection.rangeCount === 0) return false
  
  const range = selection.getRangeAt(0)
  const container = range.commonAncestorContainer
  
  let element = container.nodeType === Node.TEXT_NODE 
    ? container.parentElement 
    : container as HTMLElement
  
  while (element && element !== this.editor.contentElement) {
    if (this.isMarkElement(element, markType)) {
      return true
    }
    element = element.parentElement
  }
  
  return false
}

/**
 * åˆ›å»ºæ ‡è®°å…ƒç´ 
 */
private createMarkElement(markType: string, attrs?: Record<string, any>): HTMLElement {
  const tagMap: Record<string, string> = {
    'bold': 'strong',
    'italic': 'em',
    'underline': 'u',
    'strike': 's',
    'code': 'code',
    'superscript': 'sup',
    'subscript': 'sub'
  }
  
  const tagName = tagMap[markType] || 'span'
  const element = document.createElement(tagName)
  
  // åº”ç”¨å±æ€§
  if (attrs) {
    Object.entries(attrs).forEach(([key, value]) => {
      if (key === 'style') {
        Object.assign(element.style, value)
      } else {
        element.setAttribute(key, value)
      }
    })
  }
  
  return element
}

/**
 * åˆ¤æ–­æ˜¯å¦æ˜¯æŒ‡å®šç±»å‹çš„æ ‡è®°å…ƒç´ 
 */
private isMarkElement(element: HTMLElement, markType: string): boolean {
  const tagMap: Record<string, string> = {
    'bold': 'STRONG',
    'italic': 'EM',
    'underline': 'U',
    'strike': 'S',
    'code': 'CODE',
    'superscript': 'SUP',
    'subscript': 'SUB'
  }
  
  return element.tagName === tagMap[markType]
}
```

### å®ç°æ’¤é”€/é‡åšç³»ç»Ÿ

```typescript
// src/core/History.tsï¼ˆæ–°æ–‡ä»¶ï¼‰

export interface HistoryState {
  html: string
  selection: {
    start: number
    end: number
  }
}

export class History {
  private editor: any
  private undoStack: HistoryState[] = []
  private redoStack: HistoryState[] = []
  private maxStackSize: number = 100
  private isUndoing: boolean = false
  private isRedoing: boolean = false
  private lastSavedState: string = ''
  private saveTimeout: number | null = null
  
  constructor(editor: any) {
    this.editor = editor
    this.init()
  }
  
  private init(): void {
    // ä¿å­˜åˆå§‹çŠ¶æ€
    this.saveState()
    
    // ç›‘å¬å†…å®¹å˜åŒ–
    this.editor.on('content-change', () => {
      if (!this.isUndoing && !this.isRedoing) {
        this.debouncedSave()
      }
    })
  }
  
  /**
   * é˜²æŠ–ä¿å­˜ï¼ˆé¿å…é¢‘ç¹ä¿å­˜ï¼‰
   */
  private debouncedSave(): void {
    if (this.saveTimeout) {
      clearTimeout(this.saveTimeout)
    }
    
    this.saveTimeout = window.setTimeout(() => {
      this.saveState()
    }, 300)
  }
  
  /**
   * ä¿å­˜å½“å‰çŠ¶æ€
   */
  private saveState(): void {
    const html = this.editor.getHTML()
    
    // å¦‚æœå†…å®¹æ²¡å˜åŒ–ï¼Œä¸ä¿å­˜
    if (html === this.lastSavedState) {
      return
    }
    
    const state: HistoryState = {
      html,
      selection: this.getCurrentSelection()
    }
    
    this.undoStack.push(state)
    this.lastSavedState = html
    
    // é™åˆ¶æ ˆå¤§å°
    if (this.undoStack.length > this.maxStackSize) {
      this.undoStack.shift()
    }
    
    // æ¸…ç©ºé‡åšæ ˆ
    this.redoStack = []
  }
  
  /**
   * æ’¤é”€
   */
  undo(): boolean {
    if (this.undoStack.length <= 1) {
      return false
    }
    
    this.isUndoing = true
    
    // å°†å½“å‰çŠ¶æ€ç§»åˆ°é‡åšæ ˆ
    const currentState = this.undoStack.pop()!
    this.redoStack.push(currentState)
    
    // æ¢å¤ä¸Šä¸€ä¸ªçŠ¶æ€
    const previousState = this.undoStack[this.undoStack.length - 1]
    this.restoreState(previousState)
    
    this.isUndoing = false
    return true
  }
  
  /**
   * é‡åš
   */
  redo(): boolean {
    if (this.redoStack.length === 0) {
      return false
    }
    
    this.isRedoing = true
    
    // ä»é‡åšæ ˆå–å‡ºçŠ¶æ€
    const state = this.redoStack.pop()!
    this.undoStack.push(state)
    
    // æ¢å¤çŠ¶æ€
    this.restoreState(state)
    
    this.isRedoing = false
    return true
  }
  
  /**
   * æ¢å¤çŠ¶æ€
   */
  private restoreState(state: HistoryState): void {
    // æ¢å¤å†…å®¹
    this.editor.setHTML(state.html)
    this.lastSavedState = state.html
    
    // æ¢å¤é€‰åŒº
    setTimeout(() => {
      this.restoreSelection(state.selection)
    }, 0)
  }
  
  /**
   * è·å–å½“å‰é€‰åŒº
   */
  private getCurrentSelection(): { start: number; end: number } {
    const selection = window.getSelection()
    if (!selection || selection.rangeCount === 0) {
      return { start: 0, end: 0 }
    }
    
    const range = selection.getRangeAt(0)
    return {
      start: this.getOffset(range.startContainer, range.startOffset),
      end: this.getOffset(range.endContainer, range.endOffset)
    }
  }
  
  /**
   * æ¢å¤é€‰åŒº
   */
  private restoreSelection(selection: { start: number; end: number }): void {
    try {
      const range = this.createRangeFromOffsets(selection.start, selection.end)
      if (range) {
        const sel = window.getSelection()
        sel?.removeAllRanges()
        sel?.addRange(range)
      }
    } catch (e) {
      console.error('Failed to restore selection:', e)
    }
  }
  
  /**
   * è·å–èŠ‚ç‚¹åç§»é‡
   */
  private getOffset(node: Node, offset: number): number {
    // ç®€åŒ–å®ç°ï¼Œå®é™…åº”è¯¥éå† DOM æ ‘è®¡ç®—å‡†ç¡®åç§»
    const walker = document.createTreeWalker(
      this.editor.contentElement,
      NodeFilter.SHOW_TEXT,
      null
    )
    
    let totalOffset = 0
    let currentNode
    
    while ((currentNode = walker.nextNode())) {
      if (currentNode === node) {
        return totalOffset + offset
      }
      totalOffset += currentNode.textContent?.length || 0
    }
    
    return totalOffset
  }
  
  /**
   * ä»åç§»é‡åˆ›å»º Range
   */
  private createRangeFromOffsets(start: number, end: number): Range | null {
    // ç®€åŒ–å®ç°
    const walker = document.createTreeWalker(
      this.editor.contentElement,
      NodeFilter.SHOW_TEXT,
      null
    )
    
    let currentOffset = 0
    let startNode: Node | null = null
    let startOffset = 0
    let endNode: Node | null = null
    let endOffset = 0
    let currentNode
    
    while ((currentNode = walker.nextNode())) {
      const nodeLength = currentNode.textContent?.length || 0
      
      if (!startNode && currentOffset + nodeLength >= start) {
        startNode = currentNode
        startOffset = start - currentOffset
      }
      
      if (!endNode && currentOffset + nodeLength >= end) {
        endNode = currentNode
        endOffset = end - currentOffset
        break
      }
      
      currentOffset += nodeLength
    }
    
    if (startNode && endNode) {
      const range = document.createRange()
      range.setStart(startNode, startOffset)
      range.setEnd(endNode, endOffset)
      return range
    }
    
    return null
  }
  
  /**
   * æ¸…ç©ºå†å²
   */
  clear(): void {
    this.undoStack = []
    this.redoStack = []
    this.lastSavedState = ''
  }
  
  /**
   * æ£€æŸ¥æ˜¯å¦å¯ä»¥æ’¤é”€
   */
  canUndo(): boolean {
    return this.undoStack.length > 1
  }
  
  /**
   * æ£€æŸ¥æ˜¯å¦å¯ä»¥é‡åš
   */
  canRedo(): boolean {
    return this.redoStack.length > 0
  }
}
```

```typescript
// src/core/Command.ts - æ·»åŠ æ’¤é”€/é‡åšæ–¹æ³•

import { History } from './History'

export class CommandManager {
  // ... å…¶ä»–ä»£ç 
  
  private history: History
  
  constructor(editor: Editor) {
    this.editor = editor
    this.history = new History(editor)
  }
  
  /**
   * æ’¤é”€
   */
  undo(): boolean {
    return this.history.undo()
  }
  
  /**
   * é‡åš
   */
  redo(): boolean {
    return this.history.redo()
  }
  
  /**
   * æ£€æŸ¥æ˜¯å¦å¯ä»¥æ’¤é”€
   */
  canUndo(): boolean {
    return this.history.canUndo()
  }
  
  /**
   * æ£€æŸ¥æ˜¯å¦å¯ä»¥é‡åš
   */
  canRedo(): boolean {
    return this.history.canRedo()
  }
}
```

---

## 3. æ€§èƒ½ä¼˜åŒ–ç¤ºä¾‹

### è™šæ‹Ÿæ»šåŠ¨ï¼ˆé’ˆå¯¹è¶…é•¿æ–‡æ¡£ï¼‰

```typescript
// src/utils/VirtualScroll.ts

export interface VirtualScrollOptions {
  container: HTMLElement
  itemHeight: number
  bufferSize?: number
  renderItem: (index: number) => HTMLElement
  getTotalCount: () => number
}

export class VirtualScroll {
  private options: Required<VirtualScrollOptions>
  private scrollTop: number = 0
  private visibleStart: number = 0
  private visibleEnd: number = 0
  private itemCache: Map<number, HTMLElement> = new Map()
  
  constructor(options: VirtualScrollOptions) {
    this.options = {
      bufferSize: 5,
      ...options
    }
    
    this.init()
  }
  
  private init(): void {
    this.setupScrollListener()
    this.render()
  }
  
  private setupScrollListener(): void {
    this.options.container.addEventListener('scroll', () => {
      this.scrollTop = this.options.container.scrollTop
      this.render()
    })
  }
  
  private render(): void {
    const { container, itemHeight, bufferSize, renderItem, getTotalCount } = this.options
    const totalCount = getTotalCount()
    const containerHeight = container.clientHeight
    
    // è®¡ç®—å¯è§èŒƒå›´
    const start = Math.floor(this.scrollTop / itemHeight)
    const end = Math.ceil((this.scrollTop + containerHeight) / itemHeight)
    
    // åŠ ä¸Šç¼“å†²åŒº
    this.visibleStart = Math.max(0, start - bufferSize)
    this.visibleEnd = Math.min(totalCount, end + bufferSize)
    
    // æ¸…é™¤ä¸åœ¨å¯è§èŒƒå›´å†…çš„å…ƒç´ 
    this.itemCache.forEach((element, index) => {
      if (index < this.visibleStart || index >= this.visibleEnd) {
        element.remove()
        this.itemCache.delete(index)
      }
    })
    
    // æ¸²æŸ“å¯è§å…ƒç´ 
    for (let i = this.visibleStart; i < this.visibleEnd; i++) {
      if (!this.itemCache.has(i)) {
        const element = renderItem(i)
        element.style.position = 'absolute'
        element.style.top = `${i * itemHeight}px`
        element.style.height = `${itemHeight}px`
        container.appendChild(element)
        this.itemCache.set(i, element)
      }
    }
    
    // è®¾ç½®å®¹å™¨é«˜åº¦
    container.style.position = 'relative'
    container.style.height = `${totalCount * itemHeight}px`
  }
  
  /**
   * åˆ·æ–°
   */
  refresh(): void {
    this.itemCache.clear()
    this.options.container.innerHTML = ''
    this.render()
  }
  
  /**
   * æ»šåŠ¨åˆ°æŒ‡å®šç´¢å¼•
   */
  scrollToIndex(index: number): void {
    const top = index * this.options.itemHeight
    this.options.container.scrollTop = top
  }
}
```

### ä½¿ç”¨ requestIdleCallback ä¼˜åŒ–

```typescript
// src/utils/IdleScheduler.ts

export class IdleScheduler {
  private tasks: Array<() => void> = []
  private isRunning: boolean = false
  
  /**
   * æ·»åŠ ä»»åŠ¡
   */
  schedule(task: () => void): void {
    this.tasks.push(task)
    this.start()
  }
  
  /**
   * å¼€å§‹æ‰§è¡Œä»»åŠ¡
   */
  private start(): void {
    if (this.isRunning || this.tasks.length === 0) {
      return
    }
    
    this.isRunning = true
    this.runNextTask()
  }
  
  /**
   * æ‰§è¡Œä¸‹ä¸€ä¸ªä»»åŠ¡
   */
  private runNextTask(): void {
    if (this.tasks.length === 0) {
      this.isRunning = false
      return
    }
    
    if ('requestIdleCallback' in window) {
      requestIdleCallback((deadline) => {
        // åœ¨ç©ºé—²æ—¶é—´æ‰§è¡Œä»»åŠ¡
        while (deadline.timeRemaining() > 0 && this.tasks.length > 0) {
          const task = this.tasks.shift()!
          task()
        }
        
        // ç»§ç»­æ‰§è¡Œå‰©ä½™ä»»åŠ¡
        this.runNextTask()
      })
    } else {
      // é™çº§æ–¹æ¡ˆï¼šä½¿ç”¨ setTimeout
      setTimeout(() => {
        const task = this.tasks.shift()!
        task()
        this.runNextTask()
      }, 16)
    }
  }
  
  /**
   * æ¸…ç©ºä»»åŠ¡é˜Ÿåˆ—
   */
  clear(): void {
    this.tasks = []
    this.isRunning = false
  }
}

// ä½¿ç”¨ç¤ºä¾‹
const scheduler = new IdleScheduler()

// åœ¨ç©ºé—²æ—¶ç»Ÿè®¡å­—æ•°
scheduler.schedule(() => {
  const wordCount = calculateWordCount(editor.getHTML())
  updateWordCountDisplay(wordCount)
})

// åœ¨ç©ºé—²æ—¶è‡ªåŠ¨ä¿å­˜
scheduler.schedule(() => {
  autoSave(editor.getHTML())
})
```

---

## 4. æµ‹è¯•ç¤ºä¾‹

### å•å…ƒæµ‹è¯•ç¤ºä¾‹

```typescript
// tests/unit/core/Command.test.ts

import { describe, it, expect, beforeEach } from 'vitest'
import { Editor } from '../../../src/core/Editor'
import { CommandManager } from '../../../src/core/Command'

describe('CommandManager', () => {
  let editor: Editor
  let commands: CommandManager
  
  beforeEach(() => {
    // åˆ›å»ºæµ‹è¯•ç¼–è¾‘å™¨
    const container = document.createElement('div')
    document.body.appendChild(container)
    
    editor = new Editor({
      element: container,
      content: '<p>Hello World</p>'
    })
    
    commands = editor.commands
  })
  
  describe('toggleMark', () => {
    it('should add bold mark to selected text', () => {
      // é€‰ä¸­æ–‡æœ¬
      const p = editor.contentElement?.querySelector('p')
      const range = document.createRange()
      range.setStart(p!.firstChild!, 0)
      range.setEnd(p!.firstChild!, 5)
      
      const selection = window.getSelection()
      selection?.removeAllRanges()
      selection?.addRange(range)
      
      // æ‰§è¡ŒåŠ ç²—å‘½ä»¤
      commands.execute('toggleBold')
      
      // éªŒè¯ç»“æœ
      const html = editor.getHTML()
      expect(html).toContain('<strong>Hello</strong>')
    })
    
    it('should remove bold mark from selected text', () => {
      editor.setHTML('<p><strong>Hello</strong> World</p>')
      
      // é€‰ä¸­åŠ ç²—æ–‡æœ¬
      const strong = editor.contentElement?.querySelector('strong')
      const range = document.createRange()
      range.selectNodeContents(strong!)
      
      const selection = window.getSelection()
      selection?.removeAllRanges()
      selection?.addRange(range)
      
      // å†æ¬¡æ‰§è¡ŒåŠ ç²—å‘½ä»¤ï¼ˆåº”è¯¥ç§»é™¤ï¼‰
      commands.execute('toggleBold')
      
      // éªŒè¯ç»“æœ
      const html = editor.getHTML()
      expect(html).not.toContain('<strong>')
      expect(html).toContain('Hello')
    })
  })
  
  describe('undo/redo', () => {
    it('should undo last change', () => {
      const originalHTML = editor.getHTML()
      
      // è¿›è¡Œä¿®æ”¹
      editor.setHTML('<p>Modified</p>')
      
      // æ’¤é”€
      commands.undo()
      
      // éªŒè¯æ¢å¤åŸå§‹å†…å®¹
      expect(editor.getHTML()).toBe(originalHTML)
    })
    
    it('should redo undone change', () => {
      const modifiedHTML = '<p>Modified</p>'
      
      // è¿›è¡Œä¿®æ”¹
      editor.setHTML(modifiedHTML)
      
      // æ’¤é”€
      commands.undo()
      
      // é‡åš
      commands.redo()
      
      // éªŒè¯æ¢å¤ä¿®æ”¹åçš„å†…å®¹
      expect(editor.getHTML()).toBe(modifiedHTML)
    })
    
    it('should not undo if no history', () => {
      const result = commands.undo()
      expect(result).toBe(false)
    })
  })
})
```

### E2E æµ‹è¯•ç¤ºä¾‹

```typescript
// tests/e2e/basic-editing.spec.ts

import { test, expect } from '@playwright/test'

test.describe('Basic Editing', () => {
  test.beforeEach(async ({ page }) => {
    await page.goto('http://localhost:5173')
    await page.waitForSelector('.ldesign-editor')
  })
  
  test('should type text', async ({ page }) => {
    const editor = page.locator('.ldesign-editor-content')
    
    await editor.click()
    await editor.type('Hello World')
    
    const text = await editor.textContent()
    expect(text).toContain('Hello World')
  })
  
  test('should apply bold formatting', async ({ page }) => {
    const editor = page.locator('.ldesign-editor-content')
    const boldButton = page.locator('[data-command="bold"]')
    
    // è¾“å…¥æ–‡æœ¬
    await editor.click()
    await editor.type('Bold Text')
    
    // é€‰ä¸­æ–‡æœ¬
    await page.keyboard.press('Control+A')
    
    // ç‚¹å‡»åŠ ç²—æŒ‰é’®
    await boldButton.click()
    
    // éªŒè¯
    const html = await editor.innerHTML()
    expect(html).toContain('<strong>Bold Text</strong>')
  })
  
  test('should insert table', async ({ page }) => {
    const tableButton = page.locator('[data-command="insertTable"]')
    
    // ç‚¹å‡»è¡¨æ ¼æŒ‰é’®
    await tableButton.click()
    
    // ç­‰å¾…è¡¨æ ¼é€‰æ‹©å™¨å‡ºç°
    await page.waitForSelector('.table-grid-selector')
    
    // é€‰æ‹© 3x3 è¡¨æ ¼
    await page.locator('.table-grid-cell[data-row="2"][data-col="2"]').click()
    
    // éªŒè¯è¡¨æ ¼å·²æ’å…¥
    const editor = page.locator('.ldesign-editor-content')
    const table = editor.locator('table')
    expect(await table.count()).toBe(1)
    
    // éªŒè¯è¡Œæ•°å’Œåˆ—æ•°
    const rows = table.locator('tr')
    expect(await rows.count()).toBe(3)
  })
  
  test('should undo and redo', async ({ page }) => {
    const editor = page.locator('.ldesign-editor-content')
    
    // è¾“å…¥æ–‡æœ¬
    await editor.click()
    await editor.type('Test')
    
    // æ’¤é”€
    await page.keyboard.press('Control+Z')
    
    // éªŒè¯å†…å®¹è¢«æ’¤é”€
    let text = await editor.textContent()
    expect(text).not.toContain('Test')
    
    // é‡åš
    await page.keyboard.press('Control+Shift+Z')
    
    // éªŒè¯å†…å®¹æ¢å¤
    text = await editor.textContent()
    expect(text).toContain('Test')
  })
})
```

---

## æ€»ç»“

è¿™äº›ç¤ºä¾‹ä»£ç æä¾›äº†ï¼š

1. **ç»Ÿä¸€å³é”®èœå•ç³»ç»Ÿ** - è§£å†³ä»£ç é‡å¤é—®é¢˜
2. **å®Œæ•´çš„ Command å®ç°** - å¡«è¡¥ TODO åŠŸèƒ½
3. **æ€§èƒ½ä¼˜åŒ–æ–¹æ¡ˆ** - è™šæ‹Ÿæ»šåŠ¨å’Œç©ºé—²è°ƒåº¦
4. **æµ‹è¯•ç”¨ä¾‹æ¨¡æ¿** - å•å…ƒæµ‹è¯•å’Œ E2E æµ‹è¯•

å»ºè®®æŒ‰ç…§ä¼˜å…ˆçº§é€æ­¥å®æ–½è¿™äº›æ”¹è¿›ã€‚





