# 🔨 重构示例代码

> 本文档提供代码重构的具体实现示例  
> **状态：** 参考文档（第二阶段实施）

---

## 💡 使用说明

本文档包含三部分重要示例：
1. **统一右键菜单系统** - 解决代码重复问题
2. **完成 Command 系统** - ✅ 已实施
3. **性能优化方案** - 虚拟滚动等高级技术
4. **测试示例** - 单元测试和E2E测试

---

## 1. 统一右键菜单系统（待实施）

### 问题分析
```
❌ 当前问题：4个不同的右键菜单实现
- src/components/ContextMenuSystem.ts (578行)
- src/core/ContextMenuManager.ts (349行)
- src/ui/TableContextMenu.ts (144行)
- src/plugins/media/media-context-menu/ (249行)

💡 解决方案：统一到一个系统
- 保留 ContextMenuSystem 作为实现
- ContextMenuManager 作为管理器
- 移除重复的 TableContextMenu 和 MediaContextMenu
```

### 优化后的架构

#### 步骤1：增强 ContextMenuManager（作为统一管理器）
```typescript
// src/core/ContextMenuManager.ts（重构后）
import { ContextMenuSystem, MenuItem } from '../components/ContextMenuSystem'
import type { Editor } from './Editor'

export interface MenuRegistration {
  id: string
  selector: string | ((target: HTMLElement) => boolean)
  items: MenuItem[] | ((context: MenuContext) => MenuItem[])
  priority?: number // 优先级，数字越大优先级越高
}

export interface MenuContext {
  editor: Editor
  target: HTMLElement
  event: MouseEvent
}

export class ContextMenuManager {
  private editor: Editor
  private registrations: Map<string, MenuRegistration> = new Map()
  private currentMenu: ContextMenuSystem | null = null
  
  constructor(editor: Editor) {
    this.editor = editor
    this.setupGlobalListener()
  }
  
  /**
   * 注册右键菜单
   */
  register(registration: MenuRegistration): () => void {
    this.registrations.set(registration.id, registration)
    
    // 返回取消注册的函数
    return () => {
      this.registrations.delete(registration.id)
    }
  }
  
  /**
   * 取消注册
   */
  unregister(id: string): void {
    this.registrations.delete(id)
  }
  
  /**
   * 设置全局右键监听
   */
  private setupGlobalListener(): void {
    this.editor.contentElement?.addEventListener('contextmenu', (e) => {
      e.preventDefault()
      this.handleContextMenu(e)
    })
  }
  
  /**
   * 处理右键点击
   */
  private handleContextMenu(event: MouseEvent): void {
    const target = event.target as HTMLElement
    
    // 查找匹配的菜单注册
    const matchedRegistrations = Array.from(this.registrations.values())
      .filter(reg => this.isMatch(reg, target))
      .sort((a, b) => (b.priority || 0) - (a.priority || 0))
    
    if (matchedRegistrations.length === 0) {
      return
    }
    
    // 使用优先级最高的菜单
    const registration = matchedRegistrations[0]
    const context: MenuContext = {
      editor: this.editor,
      target,
      event
    }
    
    // 获取菜单项
    const items = typeof registration.items === 'function'
      ? registration.items(context)
      : registration.items
    
    // 关闭之前的菜单
    if (this.currentMenu) {
      this.currentMenu.hide()
    }
    
    // 显示新菜单
    this.currentMenu = new ContextMenuSystem({
      items,
      context
    })
    
    this.currentMenu.show(event.clientX, event.clientY)
  }
  
  /**
   * 判断目标元素是否匹配选择器
   */
  private isMatch(registration: MenuRegistration, target: HTMLElement): boolean {
    if (typeof registration.selector === 'function') {
      return registration.selector(target)
    }
    
    return target.matches(registration.selector) || 
           target.closest(registration.selector) !== null
  }
  
  /**
   * 销毁
   */
  destroy(): void {
    if (this.currentMenu) {
      this.currentMenu.hide()
      this.currentMenu = null
    }
    this.registrations.clear()
  }
}
```

#### 步骤2：迁移表格右键菜单
```typescript
// src/plugins/table/context-menu.ts（新文件）
import type { Editor } from '../../core/Editor'
import type { MenuContext } from '../../core/ContextMenuManager'

export function registerTableContextMenu(editor: Editor) {
  return editor.contextMenuManager?.register({
    id: 'table-menu',
    selector: 'table, th, td',
    priority: 10,
    items: (context: MenuContext) => {
      const target = context.target
      const isHeader = target.tagName === 'TH'
      const cell = target.closest('td, th') as HTMLTableCellElement
      
      return [
        {
          label: '插入行（上方）',
          icon: 'arrow-up',
          action: () => {
            editor.commands.execute('insertTableRowBefore')
          }
        },
        {
          label: '插入行（下方）',
          icon: 'arrow-down',
          action: () => {
            editor.commands.execute('insertTableRowAfter')
          }
        },
        {
          label: '删除当前行',
          icon: 'trash',
          action: () => {
            editor.commands.execute('deleteTableRow')
          }
        },
        { divider: true },
        {
          label: '插入列（左侧）',
          icon: 'arrow-left',
          action: () => {
            editor.commands.execute('insertTableColumnBefore')
          }
        },
        {
          label: '插入列（右侧）',
          icon: 'arrow-right',
          action: () => {
            editor.commands.execute('insertTableColumnAfter')
          }
        },
        {
          label: '删除当前列',
          icon: 'trash',
          action: () => {
            editor.commands.execute('deleteTableColumn')
          }
        },
        { divider: true },
        {
          label: '合并单元格',
          icon: 'merge',
          disabled: !canMergeCells(cell),
          action: () => {
            editor.commands.execute('mergeTableCells')
          }
        },
        {
          label: '拆分单元格',
          icon: 'split',
          disabled: !canSplitCell(cell),
          action: () => {
            editor.commands.execute('splitTableCell')
          }
        },
        { divider: true },
        {
          label: '删除整个表格',
          icon: 'trash-2',
          action: () => {
            if (confirm('确定要删除整个表格吗？')) {
              editor.commands.execute('deleteTable')
            }
          }
        }
      ]
    }
  })
}

function canMergeCells(cell: HTMLTableCellElement): boolean {
  // 判断是否可以合并单元格
  return window.getSelection()?.toString().includes('\t') || false
}

function canSplitCell(cell: HTMLTableCellElement): boolean {
  // 判断是否可以拆分单元格
  return (cell.colSpan > 1 || cell.rowSpan > 1)
}
```

#### 步骤3：迁移媒体右键菜单
```typescript
// src/plugins/media/context-menu.ts（新文件）
import type { Editor } from '../../core/Editor'
import type { MenuContext } from '../../core/ContextMenuManager'

export function registerMediaContextMenu(editor: Editor) {
  // 图片右键菜单
  const imageUnregister = editor.contextMenuManager?.register({
    id: 'image-menu',
    selector: 'img',
    priority: 10,
    items: (context: MenuContext) => {
      const img = context.target as HTMLImageElement
      
      return [
        {
          label: '编辑图片',
          icon: 'edit',
          action: () => {
            // 打开图片编辑对话框
            editor.commands.execute('editImage', img)
          }
        },
        {
          label: '调整大小',
          icon: 'maximize',
          submenu: [
            {
              label: '原始大小',
              action: () => {
                img.style.width = 'auto'
                img.style.height = 'auto'
              }
            },
            {
              label: '小 (200px)',
              action: () => {
                img.style.width = '200px'
                img.style.height = 'auto'
              }
            },
            {
              label: '中 (400px)',
              action: () => {
                img.style.width = '400px'
                img.style.height = 'auto'
              }
            },
            {
              label: '大 (600px)',
              action: () => {
                img.style.width = '600px'
                img.style.height = 'auto'
              }
            }
          ]
        },
        {
          label: '对齐方式',
          icon: 'align-center',
          submenu: [
            { label: '左对齐', action: () => setAlign(img, 'left') },
            { label: '居中', action: () => setAlign(img, 'center') },
            { label: '右对齐', action: () => setAlign(img, 'right') }
          ]
        },
        { divider: true },
        {
          label: '添加描述',
          icon: 'message-square',
          action: () => {
            const alt = prompt('请输入图片描述：', img.alt)
            if (alt !== null) {
              img.alt = alt
            }
          }
        },
        {
          label: '添加链接',
          icon: 'link',
          action: () => {
            editor.commands.execute('addImageLink', img)
          }
        },
        { divider: true },
        {
          label: '复制图片',
          icon: 'copy',
          action: () => {
            copyImage(img)
          }
        },
        {
          label: '删除图片',
          icon: 'trash',
          action: () => {
            if (confirm('确定要删除这张图片吗？')) {
              img.remove()
            }
          }
        }
      ]
    }
  })
  
  // 视频右键菜单
  const videoUnregister = editor.contextMenuManager?.register({
    id: 'video-menu',
    selector: 'video',
    priority: 10,
    items: (context: MenuContext) => {
      const video = context.target as HTMLVideoElement
      
      return [
        {
          label: '播放/暂停',
          icon: video.paused ? 'play' : 'pause',
          action: () => {
            if (video.paused) {
              video.play()
            } else {
              video.pause()
            }
          }
        },
        {
          label: '静音',
          icon: 'volume-x',
          checked: video.muted,
          type: 'checkbox',
          action: () => {
            video.muted = !video.muted
          }
        },
        { divider: true },
        {
          label: '删除视频',
          icon: 'trash',
          action: () => {
            if (confirm('确定要删除这个视频吗？')) {
              video.remove()
            }
          }
        }
      ]
    }
  })
  
  // 返回取消注册函数
  return () => {
    imageUnregister?.()
    videoUnregister?.()
  }
}

function setAlign(img: HTMLImageElement, align: 'left' | 'center' | 'right') {
  img.style.display = 'block'
  if (align === 'center') {
    img.style.marginLeft = 'auto'
    img.style.marginRight = 'auto'
  } else {
    img.style.float = align
  }
}

function copyImage(img: HTMLImageElement) {
  // 复制图片到剪贴板
  const canvas = document.createElement('canvas')
  canvas.width = img.naturalWidth
  canvas.height = img.naturalHeight
  const ctx = canvas.getContext('2d')
  ctx?.drawImage(img, 0, 0)
  
  canvas.toBlob((blob) => {
    if (blob) {
      navigator.clipboard.write([
        new ClipboardItem({ 'image/png': blob })
      ])
    }
  })
}
```

#### 步骤4：在插件中注册
```typescript
// src/plugins/table/index.ts
import { createPlugin } from '../../core/Plugin'
import { registerTableContextMenu } from './context-menu'

export const TablePlugin = createPlugin({
  name: 'table',
  
  init(editor) {
    // 注册右键菜单
    const unregister = registerTableContextMenu(editor)
    
    // 插件卸载时取消注册
    return () => {
      unregister?.()
    }
  },
  
  // ... 其他配置
})
```

---

## 2. 完成 Command 系统的 TODO ✅

> **状态：** ✅ 已实施  
> **文件：** `src/core/Command.ts`

### 实现的核心功能

#### toggleMark（切换标记）✅

**功能：** 切换加粗、斜体、下划线等标记

**简化实现：**
```typescript
// 使用浏览器原生 execCommand
function toggleMark(markType: string): Command {
  return (state, dispatch) => {
    if (!dispatch) return true
    
    const commandMap = {
      'bold': 'bold',
      'italic': 'italic',
      'underline': 'underline',
      'strike': 'strikeThrough'
    }
    
    document.execCommand(commandMap[markType], false)
    return true
  }
}
```

**完整实现见：** `src/core/Command.ts` 第214-253行

---

#### setBlockType（设置块类型）✅

**功能：** 转换块级元素类型（标题、段落等）

**核心逻辑：**
```typescript
function setBlockType(markType: string, attrs?: Record<string, any>): boolean {
  const selection = this.editor.getSelection()
  if (selection.isEmpty()) {
    return false
  }
  
  // 检查当前选区是否已经有该标记
  const hasMark = this.hasMarkInSelection(markType)
  
  if (hasMark) {
    // 移除标记
    this.removeMark(markType)
  } else {
    // 添加标记
    this.addMark(markType, attrs)
  }
  
  return true
}

/**
 * 添加标记
 */
private addMark(markType: string, attrs?: Record<string, any>): void {
  const selection = window.getSelection()
  if (!selection || selection.rangeCount === 0) return
  
  const range = selection.getRangeAt(0)
  
  // 创建标记元素
  const markElement = this.createMarkElement(markType, attrs)
  
  try {
    // 提取选中内容
    const contents = range.extractContents()
    
    // 将内容包装在标记元素中
    markElement.appendChild(contents)
    
    // 插入回去
    range.insertNode(markElement)
    
    // 重新选中
    selection.removeAllRanges()
    const newRange = document.createRange()
    newRange.selectNodeContents(markElement)
    selection.addRange(newRange)
    
    // 触发更新
    this.editor.emit('content-change')
  } catch (e) {
    console.error('Failed to add mark:', e)
  }
}

/**
 * 移除标记
 */
private removeMark(markType: string): void {
  const selection = window.getSelection()
  if (!selection || selection.rangeCount === 0) return
  
  const range = selection.getRangeAt(0)
  const container = range.commonAncestorContainer
  
  // 查找包含该标记的父元素
  let markElement = container.nodeType === Node.TEXT_NODE 
    ? container.parentElement 
    : container as HTMLElement
  
  while (markElement && !this.isMarkElement(markElement, markType)) {
    markElement = markElement.parentElement
  }
  
  if (markElement) {
    // 用内容替换标记元素
    const fragment = document.createDocumentFragment()
    while (markElement.firstChild) {
      fragment.appendChild(markElement.firstChild)
    }
    markElement.parentNode?.replaceChild(fragment, markElement)
    
    // 触发更新
    this.editor.emit('content-change')
  }
}

/**
 * 检查选区中是否有指定标记
 */
private hasMarkInSelection(markType: string): boolean {
  const selection = window.getSelection()
  if (!selection || selection.rangeCount === 0) return false
  
  const range = selection.getRangeAt(0)
  const container = range.commonAncestorContainer
  
  let element = container.nodeType === Node.TEXT_NODE 
    ? container.parentElement 
    : container as HTMLElement
  
  while (element && element !== this.editor.contentElement) {
    if (this.isMarkElement(element, markType)) {
      return true
    }
    element = element.parentElement
  }
  
  return false
}

/**
 * 创建标记元素
 */
private createMarkElement(markType: string, attrs?: Record<string, any>): HTMLElement {
  const tagMap: Record<string, string> = {
    'bold': 'strong',
    'italic': 'em',
    'underline': 'u',
    'strike': 's',
    'code': 'code',
    'superscript': 'sup',
    'subscript': 'sub'
  }
  
  const tagName = tagMap[markType] || 'span'
  const element = document.createElement(tagName)
  
  // 应用属性
  if (attrs) {
    Object.entries(attrs).forEach(([key, value]) => {
      if (key === 'style') {
        Object.assign(element.style, value)
      } else {
        element.setAttribute(key, value)
      }
    })
  }
  
  return element
}

/**
 * 判断是否是指定类型的标记元素
 */
private isMarkElement(element: HTMLElement, markType: string): boolean {
  const tagMap: Record<string, string> = {
    'bold': 'STRONG',
    'italic': 'EM',
    'underline': 'U',
    'strike': 'S',
    'code': 'CODE',
    'superscript': 'SUP',
    'subscript': 'SUB'
  }
  
  return element.tagName === tagMap[markType]
}
```

### 实现撤销/重做系统

```typescript
// src/core/History.ts（新文件）

export interface HistoryState {
  html: string
  selection: {
    start: number
    end: number
  }
}

export class History {
  private editor: any
  private undoStack: HistoryState[] = []
  private redoStack: HistoryState[] = []
  private maxStackSize: number = 100
  private isUndoing: boolean = false
  private isRedoing: boolean = false
  private lastSavedState: string = ''
  private saveTimeout: number | null = null
  
  constructor(editor: any) {
    this.editor = editor
    this.init()
  }
  
  private init(): void {
    // 保存初始状态
    this.saveState()
    
    // 监听内容变化
    this.editor.on('content-change', () => {
      if (!this.isUndoing && !this.isRedoing) {
        this.debouncedSave()
      }
    })
  }
  
  /**
   * 防抖保存（避免频繁保存）
   */
  private debouncedSave(): void {
    if (this.saveTimeout) {
      clearTimeout(this.saveTimeout)
    }
    
    this.saveTimeout = window.setTimeout(() => {
      this.saveState()
    }, 300)
  }
  
  /**
   * 保存当前状态
   */
  private saveState(): void {
    const html = this.editor.getHTML()
    
    // 如果内容没变化，不保存
    if (html === this.lastSavedState) {
      return
    }
    
    const state: HistoryState = {
      html,
      selection: this.getCurrentSelection()
    }
    
    this.undoStack.push(state)
    this.lastSavedState = html
    
    // 限制栈大小
    if (this.undoStack.length > this.maxStackSize) {
      this.undoStack.shift()
    }
    
    // 清空重做栈
    this.redoStack = []
  }
  
  /**
   * 撤销
   */
  undo(): boolean {
    if (this.undoStack.length <= 1) {
      return false
    }
    
    this.isUndoing = true
    
    // 将当前状态移到重做栈
    const currentState = this.undoStack.pop()!
    this.redoStack.push(currentState)
    
    // 恢复上一个状态
    const previousState = this.undoStack[this.undoStack.length - 1]
    this.restoreState(previousState)
    
    this.isUndoing = false
    return true
  }
  
  /**
   * 重做
   */
  redo(): boolean {
    if (this.redoStack.length === 0) {
      return false
    }
    
    this.isRedoing = true
    
    // 从重做栈取出状态
    const state = this.redoStack.pop()!
    this.undoStack.push(state)
    
    // 恢复状态
    this.restoreState(state)
    
    this.isRedoing = false
    return true
  }
  
  /**
   * 恢复状态
   */
  private restoreState(state: HistoryState): void {
    // 恢复内容
    this.editor.setHTML(state.html)
    this.lastSavedState = state.html
    
    // 恢复选区
    setTimeout(() => {
      this.restoreSelection(state.selection)
    }, 0)
  }
  
  /**
   * 获取当前选区
   */
  private getCurrentSelection(): { start: number; end: number } {
    const selection = window.getSelection()
    if (!selection || selection.rangeCount === 0) {
      return { start: 0, end: 0 }
    }
    
    const range = selection.getRangeAt(0)
    return {
      start: this.getOffset(range.startContainer, range.startOffset),
      end: this.getOffset(range.endContainer, range.endOffset)
    }
  }
  
  /**
   * 恢复选区
   */
  private restoreSelection(selection: { start: number; end: number }): void {
    try {
      const range = this.createRangeFromOffsets(selection.start, selection.end)
      if (range) {
        const sel = window.getSelection()
        sel?.removeAllRanges()
        sel?.addRange(range)
      }
    } catch (e) {
      console.error('Failed to restore selection:', e)
    }
  }
  
  /**
   * 获取节点偏移量
   */
  private getOffset(node: Node, offset: number): number {
    // 简化实现，实际应该遍历 DOM 树计算准确偏移
    const walker = document.createTreeWalker(
      this.editor.contentElement,
      NodeFilter.SHOW_TEXT,
      null
    )
    
    let totalOffset = 0
    let currentNode
    
    while ((currentNode = walker.nextNode())) {
      if (currentNode === node) {
        return totalOffset + offset
      }
      totalOffset += currentNode.textContent?.length || 0
    }
    
    return totalOffset
  }
  
  /**
   * 从偏移量创建 Range
   */
  private createRangeFromOffsets(start: number, end: number): Range | null {
    // 简化实现
    const walker = document.createTreeWalker(
      this.editor.contentElement,
      NodeFilter.SHOW_TEXT,
      null
    )
    
    let currentOffset = 0
    let startNode: Node | null = null
    let startOffset = 0
    let endNode: Node | null = null
    let endOffset = 0
    let currentNode
    
    while ((currentNode = walker.nextNode())) {
      const nodeLength = currentNode.textContent?.length || 0
      
      if (!startNode && currentOffset + nodeLength >= start) {
        startNode = currentNode
        startOffset = start - currentOffset
      }
      
      if (!endNode && currentOffset + nodeLength >= end) {
        endNode = currentNode
        endOffset = end - currentOffset
        break
      }
      
      currentOffset += nodeLength
    }
    
    if (startNode && endNode) {
      const range = document.createRange()
      range.setStart(startNode, startOffset)
      range.setEnd(endNode, endOffset)
      return range
    }
    
    return null
  }
  
  /**
   * 清空历史
   */
  clear(): void {
    this.undoStack = []
    this.redoStack = []
    this.lastSavedState = ''
  }
  
  /**
   * 检查是否可以撤销
   */
  canUndo(): boolean {
    return this.undoStack.length > 1
  }
  
  /**
   * 检查是否可以重做
   */
  canRedo(): boolean {
    return this.redoStack.length > 0
  }
}
```

```typescript
// src/core/Command.ts - 添加撤销/重做方法

import { History } from './History'

export class CommandManager {
  // ... 其他代码
  
  private history: History
  
  constructor(editor: Editor) {
    this.editor = editor
    this.history = new History(editor)
  }
  
  /**
   * 撤销
   */
  undo(): boolean {
    return this.history.undo()
  }
  
  /**
   * 重做
   */
  redo(): boolean {
    return this.history.redo()
  }
  
  /**
   * 检查是否可以撤销
   */
  canUndo(): boolean {
    return this.history.canUndo()
  }
  
  /**
   * 检查是否可以重做
   */
  canRedo(): boolean {
    return this.history.canRedo()
  }
}
```

---

## 3. 性能优化示例

### 虚拟滚动（针对超长文档）

```typescript
// src/utils/VirtualScroll.ts

export interface VirtualScrollOptions {
  container: HTMLElement
  itemHeight: number
  bufferSize?: number
  renderItem: (index: number) => HTMLElement
  getTotalCount: () => number
}

export class VirtualScroll {
  private options: Required<VirtualScrollOptions>
  private scrollTop: number = 0
  private visibleStart: number = 0
  private visibleEnd: number = 0
  private itemCache: Map<number, HTMLElement> = new Map()
  
  constructor(options: VirtualScrollOptions) {
    this.options = {
      bufferSize: 5,
      ...options
    }
    
    this.init()
  }
  
  private init(): void {
    this.setupScrollListener()
    this.render()
  }
  
  private setupScrollListener(): void {
    this.options.container.addEventListener('scroll', () => {
      this.scrollTop = this.options.container.scrollTop
      this.render()
    })
  }
  
  private render(): void {
    const { container, itemHeight, bufferSize, renderItem, getTotalCount } = this.options
    const totalCount = getTotalCount()
    const containerHeight = container.clientHeight
    
    // 计算可见范围
    const start = Math.floor(this.scrollTop / itemHeight)
    const end = Math.ceil((this.scrollTop + containerHeight) / itemHeight)
    
    // 加上缓冲区
    this.visibleStart = Math.max(0, start - bufferSize)
    this.visibleEnd = Math.min(totalCount, end + bufferSize)
    
    // 清除不在可见范围内的元素
    this.itemCache.forEach((element, index) => {
      if (index < this.visibleStart || index >= this.visibleEnd) {
        element.remove()
        this.itemCache.delete(index)
      }
    })
    
    // 渲染可见元素
    for (let i = this.visibleStart; i < this.visibleEnd; i++) {
      if (!this.itemCache.has(i)) {
        const element = renderItem(i)
        element.style.position = 'absolute'
        element.style.top = `${i * itemHeight}px`
        element.style.height = `${itemHeight}px`
        container.appendChild(element)
        this.itemCache.set(i, element)
      }
    }
    
    // 设置容器高度
    container.style.position = 'relative'
    container.style.height = `${totalCount * itemHeight}px`
  }
  
  /**
   * 刷新
   */
  refresh(): void {
    this.itemCache.clear()
    this.options.container.innerHTML = ''
    this.render()
  }
  
  /**
   * 滚动到指定索引
   */
  scrollToIndex(index: number): void {
    const top = index * this.options.itemHeight
    this.options.container.scrollTop = top
  }
}
```

### 使用 requestIdleCallback 优化

```typescript
// src/utils/IdleScheduler.ts

export class IdleScheduler {
  private tasks: Array<() => void> = []
  private isRunning: boolean = false
  
  /**
   * 添加任务
   */
  schedule(task: () => void): void {
    this.tasks.push(task)
    this.start()
  }
  
  /**
   * 开始执行任务
   */
  private start(): void {
    if (this.isRunning || this.tasks.length === 0) {
      return
    }
    
    this.isRunning = true
    this.runNextTask()
  }
  
  /**
   * 执行下一个任务
   */
  private runNextTask(): void {
    if (this.tasks.length === 0) {
      this.isRunning = false
      return
    }
    
    if ('requestIdleCallback' in window) {
      requestIdleCallback((deadline) => {
        // 在空闲时间执行任务
        while (deadline.timeRemaining() > 0 && this.tasks.length > 0) {
          const task = this.tasks.shift()!
          task()
        }
        
        // 继续执行剩余任务
        this.runNextTask()
      })
    } else {
      // 降级方案：使用 setTimeout
      setTimeout(() => {
        const task = this.tasks.shift()!
        task()
        this.runNextTask()
      }, 16)
    }
  }
  
  /**
   * 清空任务队列
   */
  clear(): void {
    this.tasks = []
    this.isRunning = false
  }
}

// 使用示例
const scheduler = new IdleScheduler()

// 在空闲时统计字数
scheduler.schedule(() => {
  const wordCount = calculateWordCount(editor.getHTML())
  updateWordCountDisplay(wordCount)
})

// 在空闲时自动保存
scheduler.schedule(() => {
  autoSave(editor.getHTML())
})
```

---

## 4. 测试示例

### 单元测试示例

```typescript
// tests/unit/core/Command.test.ts

import { describe, it, expect, beforeEach } from 'vitest'
import { Editor } from '../../../src/core/Editor'
import { CommandManager } from '../../../src/core/Command'

describe('CommandManager', () => {
  let editor: Editor
  let commands: CommandManager
  
  beforeEach(() => {
    // 创建测试编辑器
    const container = document.createElement('div')
    document.body.appendChild(container)
    
    editor = new Editor({
      element: container,
      content: '<p>Hello World</p>'
    })
    
    commands = editor.commands
  })
  
  describe('toggleMark', () => {
    it('should add bold mark to selected text', () => {
      // 选中文本
      const p = editor.contentElement?.querySelector('p')
      const range = document.createRange()
      range.setStart(p!.firstChild!, 0)
      range.setEnd(p!.firstChild!, 5)
      
      const selection = window.getSelection()
      selection?.removeAllRanges()
      selection?.addRange(range)
      
      // 执行加粗命令
      commands.execute('toggleBold')
      
      // 验证结果
      const html = editor.getHTML()
      expect(html).toContain('<strong>Hello</strong>')
    })
    
    it('should remove bold mark from selected text', () => {
      editor.setHTML('<p><strong>Hello</strong> World</p>')
      
      // 选中加粗文本
      const strong = editor.contentElement?.querySelector('strong')
      const range = document.createRange()
      range.selectNodeContents(strong!)
      
      const selection = window.getSelection()
      selection?.removeAllRanges()
      selection?.addRange(range)
      
      // 再次执行加粗命令（应该移除）
      commands.execute('toggleBold')
      
      // 验证结果
      const html = editor.getHTML()
      expect(html).not.toContain('<strong>')
      expect(html).toContain('Hello')
    })
  })
  
  describe('undo/redo', () => {
    it('should undo last change', () => {
      const originalHTML = editor.getHTML()
      
      // 进行修改
      editor.setHTML('<p>Modified</p>')
      
      // 撤销
      commands.undo()
      
      // 验证恢复原始内容
      expect(editor.getHTML()).toBe(originalHTML)
    })
    
    it('should redo undone change', () => {
      const modifiedHTML = '<p>Modified</p>'
      
      // 进行修改
      editor.setHTML(modifiedHTML)
      
      // 撤销
      commands.undo()
      
      // 重做
      commands.redo()
      
      // 验证恢复修改后的内容
      expect(editor.getHTML()).toBe(modifiedHTML)
    })
    
    it('should not undo if no history', () => {
      const result = commands.undo()
      expect(result).toBe(false)
    })
  })
})
```

### E2E 测试示例

```typescript
// tests/e2e/basic-editing.spec.ts

import { test, expect } from '@playwright/test'

test.describe('Basic Editing', () => {
  test.beforeEach(async ({ page }) => {
    await page.goto('http://localhost:5173')
    await page.waitForSelector('.ldesign-editor')
  })
  
  test('should type text', async ({ page }) => {
    const editor = page.locator('.ldesign-editor-content')
    
    await editor.click()
    await editor.type('Hello World')
    
    const text = await editor.textContent()
    expect(text).toContain('Hello World')
  })
  
  test('should apply bold formatting', async ({ page }) => {
    const editor = page.locator('.ldesign-editor-content')
    const boldButton = page.locator('[data-command="bold"]')
    
    // 输入文本
    await editor.click()
    await editor.type('Bold Text')
    
    // 选中文本
    await page.keyboard.press('Control+A')
    
    // 点击加粗按钮
    await boldButton.click()
    
    // 验证
    const html = await editor.innerHTML()
    expect(html).toContain('<strong>Bold Text</strong>')
  })
  
  test('should insert table', async ({ page }) => {
    const tableButton = page.locator('[data-command="insertTable"]')
    
    // 点击表格按钮
    await tableButton.click()
    
    // 等待表格选择器出现
    await page.waitForSelector('.table-grid-selector')
    
    // 选择 3x3 表格
    await page.locator('.table-grid-cell[data-row="2"][data-col="2"]').click()
    
    // 验证表格已插入
    const editor = page.locator('.ldesign-editor-content')
    const table = editor.locator('table')
    expect(await table.count()).toBe(1)
    
    // 验证行数和列数
    const rows = table.locator('tr')
    expect(await rows.count()).toBe(3)
  })
  
  test('should undo and redo', async ({ page }) => {
    const editor = page.locator('.ldesign-editor-content')
    
    // 输入文本
    await editor.click()
    await editor.type('Test')
    
    // 撤销
    await page.keyboard.press('Control+Z')
    
    // 验证内容被撤销
    let text = await editor.textContent()
    expect(text).not.toContain('Test')
    
    // 重做
    await page.keyboard.press('Control+Shift+Z')
    
    // 验证内容恢复
    text = await editor.textContent()
    expect(text).toContain('Test')
  })
})
```

---

## 总结

这些示例代码提供了：

1. **统一右键菜单系统** - 解决代码重复问题
2. **完整的 Command 实现** - 填补 TODO 功能
3. **性能优化方案** - 虚拟滚动和空闲调度
4. **测试用例模板** - 单元测试和 E2E 测试

建议按照优先级逐步实施这些改进。





