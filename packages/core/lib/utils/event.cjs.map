{"version":3,"file":"event.cjs","sources":["../../src/utils/event.ts"],"sourcesContent":["/**\r\n * 事件处理工具函数\r\n */\r\n\r\nexport interface EventOptions extends AddEventListenerOptions {\r\n  preventDefault?: boolean\r\n  stopPropagation?: boolean\r\n  stopImmediatePropagation?: boolean\r\n}\r\n\r\nexport interface DebouncedFunction<T extends (...args: any[]) => any> {\r\n  (...args: Parameters<T>): void\r\n  cancel: () => void\r\n  flush: () => void\r\n}\r\n\r\nexport interface ThrottledFunction<T extends (...args: any[]) => any> {\r\n  (...args: Parameters<T>): void\r\n  cancel: () => void\r\n}\r\n\r\n/**\r\n * 绑定事件（返回解绑函数）\r\n */\r\nexport function on(\r\n  element: Element | Document | Window,\r\n  event: string,\r\n  handler: EventListener,\r\n  options?: EventOptions,\r\n): () => void {\r\n  const wrappedHandler = (e: Event) => {\r\n    if (options?.preventDefault)\r\n      e.preventDefault()\r\n\r\n    if (options?.stopPropagation)\r\n      e.stopPropagation()\r\n\r\n    if (options?.stopImmediatePropagation)\r\n      e.stopImmediatePropagation()\r\n\r\n    handler(e)\r\n  }\r\n\r\n  element.addEventListener(event, wrappedHandler, options)\r\n\r\n  return () => {\r\n    element.removeEventListener(event, wrappedHandler, options)\r\n  }\r\n}\r\n\r\n/**\r\n * 绑定一次性事件\r\n */\r\nexport function once(\r\n  element: Element | Document | Window,\r\n  event: string,\r\n  handler: EventListener,\r\n  options?: EventOptions,\r\n): () => void {\r\n  return on(element, event, handler, { ...options, once: true })\r\n}\r\n\r\n/**\r\n * 解绑事件\r\n */\r\nexport function off(\r\n  element: Element | Document | Window,\r\n  event: string,\r\n  handler: EventListener,\r\n  options?: boolean | EventListenerOptions,\r\n): void {\r\n  element.removeEventListener(event, handler, options)\r\n}\r\n\r\n/**\r\n * 触发事件\r\n */\r\nexport function trigger(\r\n  element: Element,\r\n  event: string | Event,\r\n  detail?: any,\r\n): boolean {\r\n  let evt: Event\r\n\r\n  if (typeof event === 'string') {\r\n    evt = new CustomEvent(event, {\r\n      detail,\r\n      bubbles: true,\r\n      cancelable: true,\r\n    })\r\n  }\r\n  else {\r\n    evt = event\r\n  }\r\n\r\n  return element.dispatchEvent(evt)\r\n}\r\n\r\n/**\r\n * 防抖函数\r\n */\r\nexport function debounce<T extends (...args: any[]) => any>(\r\n  func: T,\r\n  wait: number,\r\n  immediate: boolean = false,\r\n): DebouncedFunction<T> {\r\n  let timeout: number | null = null\r\n  let result: any\r\n\r\n  const debounced = function (this: any, ...args: Parameters<T>) {\r\n    const context = this\r\n\r\n    const later = () => {\r\n      timeout = null\r\n      if (!immediate)\r\n        result = func.apply(context, args)\r\n    }\r\n\r\n    const callNow = immediate && !timeout\r\n\r\n    if (timeout)\r\n      clearTimeout(timeout)\r\n\r\n    timeout = window.setTimeout(later, wait)\r\n\r\n    if (callNow)\r\n      result = func.apply(context, args)\r\n\r\n    return result\r\n  }\r\n\r\n  debounced.cancel = () => {\r\n    if (timeout) {\r\n      clearTimeout(timeout)\r\n      timeout = null\r\n    }\r\n  }\r\n\r\n  debounced.flush = () => {\r\n    if (timeout) {\r\n      clearTimeout(timeout)\r\n      func.apply(undefined, [] as any)\r\n      timeout = null\r\n    }\r\n  }\r\n\r\n  return debounced as DebouncedFunction<T>\r\n}\r\n\r\n/**\r\n * 节流函数\r\n */\r\nexport function throttle<T extends (...args: any[]) => any>(\r\n  func: T,\r\n  wait: number,\r\n  options: { leading?: boolean, trailing?: boolean } = {},\r\n): ThrottledFunction<T> {\r\n  const { leading = true, trailing = true } = options\r\n\r\n  let timeout: number | null = null\r\n  let context: any\r\n  let args: any\r\n  let result: any\r\n  let previous = 0\r\n\r\n  const later = () => {\r\n    previous = leading === false ? 0 : Date.now()\r\n    timeout = null\r\n    result = func.apply(context, args)\r\n    if (!timeout)\r\n      context = args = null\r\n  }\r\n\r\n  const throttled = function (this: any, ...passedArgs: Parameters<T>) {\r\n    const now = Date.now()\r\n    if (!previous && leading === false)\r\n      previous = now\r\n\r\n    const remaining = wait - (now - previous)\r\n    context = this\r\n    args = passedArgs\r\n\r\n    if (remaining <= 0 || remaining > wait) {\r\n      if (timeout) {\r\n        clearTimeout(timeout)\r\n        timeout = null\r\n      }\r\n      previous = now\r\n      result = func.apply(context, args)\r\n      if (!timeout)\r\n        context = args = null\r\n    }\r\n    else if (!timeout && trailing !== false) {\r\n      timeout = window.setTimeout(later, remaining)\r\n    }\r\n\r\n    return result\r\n  }\r\n\r\n  throttled.cancel = () => {\r\n    if (timeout)\r\n      clearTimeout(timeout)\r\n\r\n    previous = 0\r\n    timeout = context = args = null\r\n  }\r\n\r\n  return throttled as ThrottledFunction<T>\r\n}\r\n\r\n/**\r\n * 事件委托\r\n */\r\nexport function delegate(\r\n  element: Element | Document,\r\n  selector: string,\r\n  event: string,\r\n  handler: (e: Event, target: Element) => void,\r\n  options?: EventOptions,\r\n): () => void {\r\n  return on(element, event, (e: Event) => {\r\n    const target = e.target as Element\r\n    const delegateTarget = target.closest(selector)\r\n\r\n    if (delegateTarget && element.contains(delegateTarget))\r\n      handler(e, delegateTarget)\r\n  }, options)\r\n}\r\n\r\n/**\r\n * 停止事件传播\r\n */\r\nexport function stop(e: Event): void {\r\n  e.preventDefault()\r\n  e.stopPropagation()\r\n}\r\n\r\n/**\r\n * 阻止默认行为\r\n */\r\nexport function prevent(e: Event): void {\r\n  e.preventDefault()\r\n}\r\n\r\n/**\r\n * 获取键盘事件的按键\r\n */\r\nexport function getKey(e: KeyboardEvent): string {\r\n  return e.key || e.keyCode.toString()\r\n}\r\n\r\n/**\r\n * 检查是否按下修饰键\r\n */\r\nexport function hasModifier(e: KeyboardEvent | MouseEvent): boolean {\r\n  return e.ctrlKey || e.metaKey || e.altKey || e.shiftKey\r\n}\r\n\r\n/**\r\n * 检查是否按下特定修饰键组合\r\n */\r\nexport function checkModifiers(\r\n  e: KeyboardEvent | MouseEvent,\r\n  modifiers: {\r\n    ctrl?: boolean\r\n    meta?: boolean\r\n    alt?: boolean\r\n    shift?: boolean\r\n  },\r\n): boolean {\r\n  const { ctrl = false, meta = false, alt = false, shift = false } = modifiers\r\n\r\n  return (\r\n    e.ctrlKey === ctrl\r\n    && e.metaKey === meta\r\n    && e.altKey === alt\r\n    && e.shiftKey === shift\r\n  )\r\n}\r\n\r\n/**\r\n * 创建长按事件\r\n */\r\nexport function onLongPress(\r\n  element: Element,\r\n  handler: (e: MouseEvent | TouchEvent) => void,\r\n  duration: number = 500,\r\n): () => void {\r\n  let timeout: number | null = null\r\n  let startEvent: MouseEvent | TouchEvent | null = null\r\n\r\n  const start = (e: MouseEvent | TouchEvent) => {\r\n    startEvent = e\r\n    timeout = window.setTimeout(() => {\r\n      handler(startEvent!)\r\n      timeout = null\r\n    }, duration)\r\n  }\r\n\r\n  const cancel = () => {\r\n    if (timeout) {\r\n      clearTimeout(timeout)\r\n      timeout = null\r\n    }\r\n    startEvent = null\r\n  }\r\n\r\n  const offs: (() => void)[] = []\r\n\r\n  // 鼠标事件\r\n  offs.push(on(element, 'mousedown', start as EventListener))\r\n  offs.push(on(element, 'mouseup', cancel as EventListener))\r\n  offs.push(on(element, 'mouseleave', cancel as EventListener))\r\n\r\n  // 触摸事件\r\n  offs.push(on(element, 'touchstart', start as EventListener))\r\n  offs.push(on(element, 'touchend', cancel as EventListener))\r\n  offs.push(on(element, 'touchcancel', cancel as EventListener))\r\n\r\n  return () => {\r\n    cancel()\r\n    offs.forEach(off => off())\r\n  }\r\n}\r\n\r\n/**\r\n * 创建拖拽事件\r\n */\r\nexport function onDrag(\r\n  element: Element,\r\n  handlers: {\r\n    onStart?: (e: MouseEvent | TouchEvent, pos: { x: number, y: number }) => void\r\n    onMove?: (e: MouseEvent | TouchEvent, pos: { x: number, y: number }, delta: { x: number, y: number }) => void\r\n    onEnd?: (e: MouseEvent | TouchEvent, pos: { x: number, y: number }) => void\r\n  },\r\n): () => void {\r\n  let isDragging = false\r\n  let startX = 0\r\n  let startY = 0\r\n  let currentX = 0\r\n  let currentY = 0\r\n\r\n  const getPosition = (e: MouseEvent | TouchEvent) => {\r\n    if ('touches' in e) {\r\n      return {\r\n        x: e.touches[0].clientX,\r\n        y: e.touches[0].clientY,\r\n      }\r\n    }\r\n    return {\r\n      x: e.clientX,\r\n      y: e.clientY,\r\n    }\r\n  }\r\n\r\n  const handleStart = (e: MouseEvent | TouchEvent) => {\r\n    isDragging = true\r\n    const pos = getPosition(e)\r\n    startX = currentX = pos.x\r\n    startY = currentY = pos.y\r\n\r\n    handlers.onStart?.(e, pos)\r\n  }\r\n\r\n  const handleMove = (e: MouseEvent | TouchEvent) => {\r\n    if (!isDragging)\r\n      return\r\n\r\n    const pos = getPosition(e)\r\n    const delta = {\r\n      x: pos.x - currentX,\r\n      y: pos.y - currentY,\r\n    }\r\n\r\n    currentX = pos.x\r\n    currentY = pos.y\r\n\r\n    handlers.onMove?.(e, pos, delta)\r\n  }\r\n\r\n  const handleEnd = (e: MouseEvent | TouchEvent) => {\r\n    if (!isDragging)\r\n      return\r\n\r\n    isDragging = false\r\n    const pos = getPosition(e)\r\n\r\n    handlers.onEnd?.(e, pos)\r\n  }\r\n\r\n  const offs: (() => void)[] = []\r\n\r\n  // 鼠标事件\r\n  offs.push(on(element, 'mousedown', handleStart as EventListener))\r\n  offs.push(on(document, 'mousemove', handleMove as EventListener))\r\n  offs.push(on(document, 'mouseup', handleEnd as EventListener))\r\n\r\n  // 触摸事件\r\n  offs.push(on(element, 'touchstart', handleStart as EventListener, { passive: false }))\r\n  offs.push(on(document, 'touchmove', handleMove as EventListener, { passive: false }))\r\n  offs.push(on(document, 'touchend', handleEnd as EventListener))\r\n  offs.push(on(document, 'touchcancel', handleEnd as EventListener))\r\n\r\n  return () => {\r\n    offs.forEach(off => off())\r\n  }\r\n}\r\n\r\n/**\r\n * 监听元素尺寸变化\r\n */\r\nexport function onResize(\r\n  element: Element,\r\n  handler: (entries: ResizeObserverEntry[]) => void,\r\n): () => void {\r\n  if (!window.ResizeObserver) {\r\n    console.warn('ResizeObserver is not supported')\r\n    return () => {}\r\n  }\r\n\r\n  const observer = new ResizeObserver(handler)\r\n  observer.observe(element)\r\n\r\n  return () => {\r\n    observer.disconnect()\r\n  }\r\n}\r\n\r\n/**\r\n * 监听元素可见性变化\r\n */\r\nexport function onVisibilityChange(\r\n  element: Element,\r\n  handler: (isVisible: boolean, entry: IntersectionObserverEntry) => void,\r\n  options?: IntersectionObserverInit,\r\n): () => void {\r\n  if (!window.IntersectionObserver) {\r\n    console.warn('IntersectionObserver is not supported')\r\n    return () => {}\r\n  }\r\n\r\n  const observer = new IntersectionObserver((entries) => {\r\n    entries.forEach((entry) => {\r\n      handler(entry.isIntersecting, entry)\r\n    })\r\n  }, options)\r\n\r\n  observer.observe(element)\r\n\r\n  return () => {\r\n    observer.disconnect()\r\n  }\r\n}\r\n\r\n/**\r\n * 等待事件触发\r\n */\r\nexport function waitForEvent(\r\n  element: Element | Document | Window,\r\n  event: string,\r\n  timeout?: number,\r\n): Promise<Event> {\r\n  return new Promise((resolve, reject) => {\r\n    let timeoutId: number | null = null\r\n\r\n    const cleanup = () => {\r\n      if (timeoutId)\r\n        clearTimeout(timeoutId)\r\n\r\n      off(element, event, handler)\r\n    }\r\n\r\n    const handler = (e: Event) => {\r\n      cleanup()\r\n      resolve(e)\r\n    }\r\n\r\n    on(element, event, handler, { once: true })\r\n\r\n    if (timeout) {\r\n      timeoutId = window.setTimeout(() => {\r\n        cleanup()\r\n        reject(new Error(`Event \"${event}\" timeout after ${timeout}ms`))\r\n      }, timeout)\r\n    }\r\n  })\r\n}\r\n\r\n/**\r\n * 事件处理器类型\r\n */\r\nexport type EventHandler = (...args: any[]) => void\r\n\r\n/**\r\n * 事件映射类型\r\n */\r\nexport type EventMap = Record<string, any[]>\r\n\r\n/**\r\n * 增强的事件发射器（支持泛型）\r\n */\r\nexport class EventEmitter<T extends Record<string, any[]> = Record<string, any[]>> {\r\n  private events: Map<keyof T, Set<Function>> = new Map()\r\n\r\n  on<K extends keyof T>(event: K, handler: (...args: T[K]) => void): () => void {\r\n    if (!this.events.has(event))\r\n      this.events.set(event, new Set())\r\n\r\n    this.events.get(event)!.add(handler)\r\n\r\n    return () => this.off(event, handler)\r\n  }\r\n\r\n  once<K extends keyof T>(event: K, handler: (...args: T[K]) => void): () => void {\r\n    const wrappedHandler = (...args: T[K]) => {\r\n      handler(...args)\r\n      this.off(event, wrappedHandler)\r\n    }\r\n\r\n    return this.on(event, wrappedHandler)\r\n  }\r\n\r\n  off<K extends keyof T>(event: K, handler: (...args: T[K]) => void): void {\r\n    const handlers = this.events.get(event)\r\n    if (handlers) {\r\n      handlers.delete(handler)\r\n      if (handlers.size === 0)\r\n        this.events.delete(event)\r\n    }\r\n  }\r\n\r\n  emit<K extends keyof T>(event: K, ...args: T[K]): void {\r\n    const handlers = this.events.get(event)\r\n    if (handlers) {\r\n      handlers.forEach((handler) => {\r\n        try {\r\n          handler(...args)\r\n        }\r\n        catch (error) {\r\n          console.error(`Error in event handler for \"${String(event)}\":`, error)\r\n        }\r\n      })\r\n    }\r\n  }\r\n\r\n  clear(event?: keyof T): void {\r\n    if (event)\r\n      this.events.delete(event)\r\n    else\r\n      this.events.clear()\r\n  }\r\n\r\n  listenerCount(event: keyof T): number {\r\n    return this.events.get(event)?.size || 0\r\n  }\r\n}\r\n"],"names":["EventEmitter","events","Map","on","event","handler","has","set","Set","get","add","off","once","wrappedHandler","args","handlers","delete","size","emit","forEach","error","console","String","clear","listenerCount"],"mappings":";;;;;;;;;;;AAqfO,MAAMA,YAAAA,CAAsE;AAAA,EAA5E,WAAA,GAAA;AACL,IAAA,IAAA,CAAQC,MAAAA,uBAA0CC,GAAAA,EAAI;AAAA,EAAA;AAAA,EAEtDC,EAAAA,CAAsBC,OAAUC,OAAAA,EAA8C;AAC5E,IAAA,IAAI,CAAC,IAAA,CAAKJ,MAAAA,CAAOK,GAAAA,CAAIF,KAAK,CAAA;AACxB,MAAA,IAAA,CAAKH,MAAAA,CAAOM,GAAAA,CAAIH,KAAAA,kBAAO,IAAII,KAAK,CAAA;AAElC,IAAA,IAAA,CAAKP,MAAAA,CAAOQ,GAAAA,CAAIL,KAAK,CAAA,CAAGM,IAAIL,OAAO,CAAA;AAEnC,IAAA,OAAO,MAAM,IAAA,CAAKM,GAAAA,CAAIP,KAAAA,EAAOC,OAAO,CAAA;AAAA,EACtC;AAAA,EAEAO,IAAAA,CAAwBR,OAAUC,OAAAA,EAA8C;AAC9E,IAAA,MAAMQ,cAAAA,GAAiBA,IAAIC,IAAAA,KAAe;AACxCT,MAAAA,OAAAA,CAAQ,GAAGS,IAAI,CAAA;AACf,MAAA,IAAA,CAAKH,GAAAA,CAAIP,OAAOS,cAAc,CAAA;AAAA,IAChC,CAAA;AAEA,IAAA,OAAO,IAAA,CAAKV,EAAAA,CAAGC,KAAAA,EAAOS,cAAc,CAAA;AAAA,EACtC;AAAA,EAEAF,GAAAA,CAAuBP,OAAUC,OAAAA,EAAwC;AACvE,IAAA,MAAMU,QAAAA,GAAW,IAAA,CAAKd,MAAAA,CAAOQ,GAAAA,CAAIL,KAAK,CAAA;AACtC,IAAA,IAAIW,QAAAA,EAAU;AACZA,MAAAA,QAAAA,CAASC,OAAOX,OAAO,CAAA;AACvB,MAAA,IAAIU,SAASE,IAAAA,KAAS,CAAA;AACpB,QAAA,IAAA,CAAKhB,MAAAA,CAAOe,OAAOZ,KAAK,CAAA;AAAA,IAC5B;AAAA,EACF;AAAA,EAEAc,IAAAA,CAAwBd,UAAaU,IAAAA,EAAkB;AACrD,IAAA,MAAMC,QAAAA,GAAW,IAAA,CAAKd,MAAAA,CAAOQ,GAAAA,CAAIL,KAAK,CAAA;AACtC,IAAA,IAAIW,QAAAA,EAAU;AACZA,MAAAA,QAAAA,CAASI,QAASd,CAAAA,OAAAA,KAAY;AAC5B,QAAA,IAAI;AACFA,UAAAA,OAAAA,CAAQ,GAAGS,IAAI,CAAA;AAAA,QACjB,SACOM,KAAAA,EAAO;AACZC,UAAAA,OAAAA,CAAQD,MAAM,CAAA,4BAAA,EAA+BE,MAAAA,CAAOlB,KAAK,CAAC,MAAMgB,KAAK,CAAA;AAAA,QACvE;AAAA,MACF,CAAC,CAAA;AAAA,IACH;AAAA,EACF;AAAA,EAEAG,MAAMnB,KAAAA,EAAuB;AAC3B,IAAA,IAAIA,KAAAA;AACF,MAAA,IAAA,CAAKH,MAAAA,CAAOe,OAAOZ,KAAK,CAAA;AAAA;AAExB,MAAA,IAAA,CAAKH,OAAOsB,KAAAA,EAAM;AAAA,EACtB;AAAA,EAEAC,cAAcpB,KAAAA,EAAwB;AACpC,IAAA,OAAO,IAAA,CAAKH,MAAAA,CAAOQ,GAAAA,CAAIL,KAAK,GAAGa,IAAAA,IAAQ,CAAA;AAAA,EACzC;AACF;;;;;;;"}